import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { getAuthenticatedUser } from '@/lib/api-key-auth'

export async function GET(request: NextRequest) {
  try {
    const user = await getAuthenticatedUser(request)
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const now = new Date()
    const yesterday = new Date(now)
    yesterday.setDate(yesterday.getDate() - 1)
    yesterday.setHours(0, 0, 0, 0)

    // Get approval queue count
    const approvalQueueCount = await prisma.outreachMessage.count({
      where: {
        prospect: {
          companyId: user.companyId,
        },
        approvalStatus: 'pending',
        step: 1,
        status: 'pending',
      },
    })

    // Get hot prospects (high engagement in last 24h)
    const recentActivities = await prisma.prospectActivity.findMany({
      where: {
        prospect: {
          companyId: user.companyId,
        },
        createdAt: { gte: yesterday },
        OR: [
          { openedAt: { not: null } },
          { clickedAt: { not: null } },
          { outcome: 'interested' },
        ],
      },
      include: {
        prospect: {
          select: {
            id: true,
            companyName: true,
            status: true,
          },
        },
      },
    })

    // Calculate engagement scores
    const prospectEngagement = new Map<string, number>()
    recentActivities.forEach((activity) => {
      const prospectId = activity.prospectId
      const current = prospectEngagement.get(prospectId) || 0
      let score = current
      if (activity.openedAt) score += 10
      if (activity.clickedAt) score += 20
      if (activity.outcome === 'interested') score += 50
      prospectEngagement.set(prospectId, score)
    })

    const hotProspects = Array.from(prospectEngagement.entries())
      .filter(([_, score]) => score >= 20)
      .map(([prospectId, score]) => {
        const prospect = recentActivities.find(
          (a) => a.prospectId === prospectId
        )?.prospect
        if (!prospect) return null
        return {
          id: prospect.id,
          companyName: prospect.companyName,
          status: prospect.status,
          lastActivity: recentActivities
            .filter((a) => a.prospectId === prospectId)
            .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0]
            ?.createdAt.toISOString() || new Date().toISOString(),
          engagementScore: score,
        }
      })
      .filter((p): p is NonNullable<typeof p> => p !== null)
      .slice(0, 10)

    // Get overnight activity from automation logs
    const automationLogs = await prisma.growthAutomationLog.findMany({
      where: {
        companyId: user.companyId,
        createdAt: { gte: yesterday },
        status: 'completed',
      },
      orderBy: {
        createdAt: 'desc',
      },
    })

    // Get overnight messages sent
    const overnightMessages = await prisma.outreachMessage.count({
      where: {
        prospect: {
          companyId: user.companyId,
        },
        sentAt: { gte: yesterday },
        isAiGenerated: true,
      },
    })

    // Get new prospects discovered
    const newProspects = await prisma.prospect.count({
      where: {
        companyId: user.companyId,
        createdAt: { gte: yesterday },
        source: 'ai_discovery',
      },
    })

    // Get pipeline movements
    const pipelineMovements = await prisma.prospectActivity.count({
      where: {
        prospect: {
          companyId: user.companyId,
        },
        createdAt: { gte: yesterday },
        type: 'status_change',
      },
    })

    const overnightActivity = [
      {
        type: 'messages_sent',
        count: overnightMessages,
        description: 'AI-generated messages sent',
      },
      {
        type: 'prospects_discovered',
        count: newProspects,
        description: 'New prospects discovered',
      },
      {
        type: 'pipeline_movements',
        count: pipelineMovements,
        description: 'Pipeline status updates',
      },
    ].filter((a) => a.count > 0)

    // Get pipeline movement (status changes in last 24h)
    // Note: This would require tracking status changes, for now we'll use activity logs
    const pipelineMovement: Array<{
      prospectId: string
      prospectName: string
      fromStatus: string
      toStatus: string
      movedAt: string
    }> = []

    // Get AI insights (placeholder - would be generated by AI)
    const aiInsights = [
      {
        type: 'performance',
        title: 'Best Performing Template',
        description: 'Your "Restaurant Introduction" template has a 12% response rate this week',
        action: 'View Template',
      },
      {
        type: 'timing',
        title: 'Optimal Send Time',
        description: 'Prospects respond best to emails sent Tuesday-Thursday at 10am',
        action: 'Adjust Schedule',
      },
    ]

    return NextResponse.json({
      approvalQueueCount,
      hotProspects,
      overnightActivity,
      pipelineMovement,
      aiInsights,
    })
  } catch (error) {
    console.error('Error fetching command center:', error)
    return NextResponse.json(
      { error: 'Failed to fetch command center data' },
      { status: 500 }
    )
  }
}
